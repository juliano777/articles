Gerenciamento Fácil de Backups PostgreSQL com pgBarman - Agora com Backup Incremental! 

Juliano Atanazio

http://docs.pgbarman.org/#introduction

==========================================================================

Convenções


Comando como root é sempre precedido de sustenido:

# comando


Comando como usuário comum sempre precedido de cifrão:

$ comando



==========================================================================

Por que precisamos de Backup


Em um mundo ideal não precisaríamos de backup.
No entanto, especialmente em um ambiente de negócios, 
precisamos estar preparados caso aconteça algo inesperado.

Como por exemplo:

- Corrupção de dados;

- Falha de sistema (hardware ou software);

- Erro humano;

- Desastres naturais;

- Etc.

==========================================================================

Por que precisamos de Backup


Como não poderia ser diferente de outras áreas, backups de bancos de dados são fundamentais.
No mundo atual Informação tem muito valor.

Backups possibilitam fazer o que chamamos de "recovery", ou seja uma recuperação
de um desastre.

Ter um gerenciamento de backups eficiente pode salvar muitas coisas (vidas, empregos, 
dinheiro, energia e etc...)


==========================================================================

Apresentação

O que é o pgBarman?

pgBarman ou simplesmente Barman (Backup and Recovery Manager) é uma ferramenta open source 
de administração de backup e recuperação de disastres de servidores PostgreSQL escrita em 
Python.

Permite  fazer  backups  remotos  de  múltiplos  servidores  em  ambientes 
críticos de negócios e auxilia DBAs durante a fase de recuperação.

Dentre seus mais úteis recursos incluem backup de catálogos, políticas de 
retenção, recuperação remota, arquivamento e compressão de arquivos de 
WAL.

O Barman foi desenvolvido e é mantido pelos profissionais PostgreSQL da 
2ndQuadrant.

==========================================================================

Apresentação

Características e Objetivos


Backup físico full a quente de servidores PostgreSQL;

Gerenciamento de múltiplos servidores;

Recuperação remota e local;

Suporte a operações remotas via SSH;

Informações sobre estado de servidores;

Backup incremental;

Gerenciamento de políticas de retenção para backups e arquivos WAL;

==========================================================================

Apresentação

Características e Objetivos


Compressão de arquivos WAL (bzip2, gzip ou customizado);

Integração com ferramentas padrão de arquivamento (e.g. tar);

Scripts de gancho (hook scripts) pré / pós bakcup;

Armazenamento local de metadados;

Point-In-Time-Recovery (PITR);

Backup remoto (incluindo servidor standby a apartir da versão 9.2);

==========================================================================

Apresentação

Características e Objetivos


Gerenciamento de backups base e arquivo de WAL através de um catálogo;

Arquivo de configuração simples (estilo INI);

Totalmente escrito em Python;

Relocação do PGDATA e tablespace durante a recuperação;

Informações gerais de uso de disco por backups;

Diagnósticos de servidor para backup;


Suporte rsync sobre SSH para sincronização de arquivos e transferências.

==========================================================================

Apresentação

Licença

Barman  é  propriedade  exclusiva  da  2ndQuadrant  Itália  e  seu  código  é 
distribuído sob a licença GPLv3.

Contribuições  ao  Barman  são  bem  vindas,  e  serão  listadas  no  arquivo 
AUTHORS.


==========================================================================

Apresentação

Suporte


Site oficial:  
http://www.pgbarman.org
Blog:  
http://www.pgbarman.org/blog/
Lista de discussão: 
https://groups.google.com/group/pgbarman
Canal IRC: 
irc://irc.freenode.net/barman
Suporte de Serviços da 2ndQuadrant
FAQ: 
http://www.pgbarman.org/FAQ/
Documentação oficial: 
http://www.pgbarman.org/documentation/


==========================================================================

Cenário de Testes


Hostname: srv-backup.dominio
IP: 192.168.7.70
System User: barman


Hostname: srv-pgsql.dominio
IP: 192.168.7.71
System User: postgres

Ambos: Debian

==========================================================================

Requerimentos

    Linux/Unix
    Python 2.6 or 2.7
    Python modules:
        argcomplete
        argh >= 0.21.2
        psycopg2
        python-dateutil < 2.0 (since version 2.0 requires python3)
        distribute (optional)
    PostgreSQL >= 8.3
    rsync >= 3.0.4

==========================================================================

Requerimentos

Para distribuições como RedHat, CentOS e Scientific Linux é necessário instalar
o repositório Extra Packages Enterprise Linux (EPEL).

Para uma operação de Point-In-Time-Recovery (PITR) é preciso que a versão majoritária (X.Y) do 
servidor PostgreSQL de origem seja a mesma instalada no servidor de destino.

==========================================================================

Instalação do Servidor de Backup Barman

Debian / Ubuntu


O método mais recomendado para instalar o Barman no Debian ou Ubuntu é através do repositório APT da Comunidade PostgreSQL (PGDG -
PostgreSQL Global Development Group).
As instruções para configuração do repositório podem ser encontradas no seguinte endereço:

https://wiki.postgresql.org/wiki/Apt

Com o repositório citado devidamente configurado dê o seguinte comando:

# aptitude -y install barman rsync python-{argcomplete,argh,argparse,dateutil,psycopg2} bash-completion

==========================================================================




# wget -c \
http://ufpr.dl.sourceforge.net/project/pgbarman/1.4.0/barman-1.4.0.tar.gz \
-P  /usr/src/

# tar xf /usr/src/barman-1.4.0.tar.gz -C /usr/src/

# cp /usr/src/barman-1.4.0/scripts/barman.bash_completion /etc/bash_completion.d/barman

==========================================================================



Instalação do Servidor de Backup Barman

Debian / Ubuntu

Com a instalação do pacote também são feitas as criações de grupo e usuário
de sistema para o Barman:

fgrep barman /etc/passwd
barman:x:106:110:Backup and Recovery Manager for PostgreSQL,,,:/var/lib/barman:/bin/bash

Podemos constatar:

UID (User ID): 106
GID (Group ID): 110
HOME: /var/lib/barman
SHELL: /bin/bash

==========================================================================

Instalação do Servidor de Backup Barman

Debian / Ubuntu

Um detalhe que infelizmente poucos se administradores se preocupam é a questão do
ID de usuário e de grupo de sistema.

Felizmente na instalação do Barman via APT isso é respeitado:

# id barman
uid=106(barman) gid=110(barman) groups=110(barman)

Dica de leitura:

http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/uidrange.html

Definindo o hostname:

# echo 'srv-backup.dominio' > /etc/hostname


==========================================================================

Instalação do Servidor de Backup Barman

RedHat / CentOS / Scientific Linux

Como já citado antes para esse tipo de distro Linux é preciso ter o repositório
EPEL instalado. Os links para os pacotes RPM e instruções gerais podem ser encontrados em:

https://fedoraproject.org/wiki/EPEL


Também há um repositório PGDG para distribuições desse tipo que deve ser configurado:

http://yum.postgresql.org/


==========================================================================

Instalação do Servidor de Backup Barman

RedHat / CentOS / Scientific Linux


Após repositórios YUM devidamente configurados, a instalação do pacote:

# yum -y install barman rsync


Como acontece com distos Debian, há também a criação de usuário e grupo de sistema para o Barman:

# fgrep barman /etc/passwd
barman:x:497:494:Backup and Recovery Manager for PostgreSQL:/var/lib/barman:/bin/bash

# sed -i 's/\(HOSTNAME=\).*/\1srv-backup.dominio/g' /etc/sysconfig/network

==========================================================================

Instalação do Servidor de Backup Barman

# rsync -av /etc/skel/ ~barman/

# chown -R barman: ~barman

Arquivo /etc/hosts:

# cat << EOF > /etc/hosts 
127.0.0.1       localhost
127.0.1.1       srv-backup.dominio    srv-backup
192.168.7.70    srv-backup.dominio    srv-backup
192.168.7.71    srv-pgsql.dominio     srv-pgsql
EOF


==========================================================================

Preparação do Servidor de Banco de Dados 


É preciso fazer alguns ajustes no servidor cuja base serão feitos backups.

Consideremos que o PostgreSQL já esteja instalado, para os testes será usada
a versão 9.4.

Para o nosso laboratório de testes a base de dados de exemplo será a bem conhecida
pagila [1].

[1] http://pgfoundry.org/frs/?group_id=1000150&release_id=998

==========================================================================

Preparação do Servidor de Banco de Dados 


Definindo o hostname:

# echo 'srv-pgsql.dominio' > /etc/hostname

Redefinindo o arquivo /etc/hosts:

# cat << EOF > /etc/hosts 
127.0.0.1       localhost
127.0.1.1       srv-pgsql.dominio    srv-pgsql
192.168.7.70    srv-backup.dominio   srv-backup
192.168.7.71    srv-pgsql.dominio    srv-pgsql
EOF

==========================================================================

Comunicação SSH Bi-Direcional


É necessário configurar a comunicação SSH sem senha entre o servidor de
backup Barman e cada um dos servidores de banco de dados PostgreSQL a ser 
gerenciado.

A comunicação tem que ser bi-direcional utilizando os usuários de sistema.
Não utilizar o usuário root.

Servidor Barman - Usuário: barman

Servidor PostgreSQL - Usuário: postgres

==========================================================================

Comunicação SSH Bi-Direcional


A comunicação precisa ser bi-direcional porque:

- PostgreSQL acessando o Barman:

O envio de arquivos WAL para o servidor de backup (parâmetro archive_command);


- Barman acessando o PostgreSQL:

Para uma restauração remota.

==========================================================================

Comunicação SSH Bi-Direcional

Em ambos os servidores (usuários barman no Servidor de Backup e postgres
no Servidor de Banco de Dados):


$ ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa

Enfim foi gerada a chave pública que será enviada para o outro servidor.

Do servidor de banco de dados para o backup e vice-versa.


==========================================================================

Comunicação SSH Bi-Direcional

Envio de Chave Pública para o Outro Servidor - Variáveis de Ambiente


Para facilitar o processo de troca de chaves serão criadas as variáveis de
ambiente pertinentes à ação a ser executada em um servidor.


==========================================================================

Comunicação SSH Bi-Direcional

Envio de Chave Pública para o Outro Servidor - Variáveis de Ambiente

(Servidor de Backup Barman)

# export USUARIO_ORIGEM='barman'
# export USUARIO_CONEXAO='root'
# export USUARIO_DESTINO='postgres'
# export SERVIDOR='srv-pgsql'


==========================================================================

Comunicação SSH Bi-Direcional

Envio de Chave Pública para o Outro Servidor - Variáveis de Ambiente

(Servidor de Banco de Dados PostgreSQL)

# export USUARIO_ORIGEM='postgres'
# export USUARIO_CONEXAO='root'
# export USUARIO_DESTINO='barman'
# export SERVIDOR='srv-backup'

==========================================================================

Comunicação SSH Bi-Direcional

Envio de Chave Pública para o Outro Servidor - Variáveis de Ambiente

(Ambos os Servidores)

# cat `eval echo ~${USUARIO_ORIGEM}`/.ssh/id_rsa.pub | \
ssh ${USUARIO_CONEXAO}@${SERVIDOR} \
"cat - >> `eval echo ~${USUARIO_DESTINO}`/.ssh/authorized_keys"

# ssh root@${SERVIDOR} "chown -R ${USUARIO_DESTINO}: ~${USUARIO_DESTINO}/.ssh"

# ssh root@${SERVIDOR} "chmod 0700 ~${USUARIO_DESTINO}/.ssh"

# su ${USUARIO_ORIGEM} -c "ssh ${USUARIO_DESTINO}@${SERVIDOR}"

==========================================================================

Comunicação SSH Bi-Direcional

Testando a Conexão

(Ambos os Servidores)

# su ${USUARIO_ORIGEM} -c \
'ssh -o "StrictHostKeyChecking = no" ${USUARIO_DESTINO}@${SERVIDOR}'


==========================================================================

Comunicação SSH Bi-Direcional

Testando a Conexão - Servidor de Backup (como usuário barman)

$ ssh -o "StrictHostKeyChecking = no" postgres@srv-pgsql

A parâmetro "-o", cuja isntrução "StrictHostKeyChecking = no" faz com que
na primeira conexão não seja pedida a verificação de host, fazendo com que
nas próximas conexões seja necessário apenas:

$ ssh postgres@srv-pgsql

==========================================================================

Comunicação SSH Bi-Direcional

Testando a Conexão - Servidor de Banco de Dados (como usuário postgres)

$ ssh -o "StrictHostKeyChecking = no" barman@srv-backup

A parâmetro "-o", cuja isntrução "StrictHostKeyChecking = no" faz com que
na primeira conexão não seja pedida a verificação de host, fazendo com que
nas próximas conexões seja necessário apenas:

$ ssh barman@srv-backup

==========================================================================



Preparação do Servidor de Banco de Dados 


É preciso dar permissão no pg_hba.conf para que o servidor de backup possa se conectar:


# echo -e "host\tall\tbarman\tsrv-backup.dominio\tmd5" \
>> /etc/postgresql/9.4/main/pg_hba.conf


# sed -i "s:\(^host.*\(all.*\)\{2\}.*127.0.0.1.*\)md5:\1trust:g" \
/etc/postgresql/9.4/main/pg_hba.conf


# sed "s:\(^#listen.*\):\1\nlisten_addresses = 'localhost, 192.168.7.71':g" -i \
/etc/postgresql/9.4/main/postgresql.conf

# sed "s:\(^#wal_level = .*\):\1\nwal_level = archive:g" -i \
/etc/postgresql/9.4/main/postgresql.conf

# sed "s:\(^#archive_mode = .*\):\1\narchive_mode = on:g" -i \
/etc/postgresql/9.4/main/postgresql.conf


# sed "s;\(^#archive_command.*\);\1\narchive_command = \
'scp %p barman@srv-backup:/var/lib/barman/bkp/srv-pgsql/incoming/%f';g" -i \
/etc/postgresql/9.4/main/postgresql.conf


# service postgresql restart


# su - postgres


$ createdb pagila

==========================================================================

Preparação do Servidor de Banco de Dados 


$ wget -c http://pgfoundry.org/frs/download.php/1719/pagila-0.10.1.zip \
-O /tmp/pagila.zip

$ unzip /tmp/pagila.zip -d /tmp/

$ psql -f /tmp/pagila-0.10.1/pagila-schema.sql pagila

$ psql -f /tmp/pagila-0.10.1/pagila-data.sql pagila

$ psql -c "CREATE ROLE barman LOGIN SUPERUSER PASSWORD 'senha';"

==========================================================================

Configuração do Barman

Diretório de Backup


O Barman precisa de um diretório principal de backup para armazenar todos
backups, através do qual pode-se definir uma pasta para cada servidor que fará
backup e para cada tipo de recurso (backup ou segmentos WAL, por instância).

Recomenda-se que sejam usadas as convenções que o Barman escolhe.

O arquivo de configuração define o parâmetro barman_home, que é o diretório
onde o Barman armazenará todos os backups por padrão.

Esse diretório é o “home” para o usuário de sistema do Barman.
Por padrão é o diretório /var/lib/barman.
==========================================================================

Configuração do Barman

Configuração Básica


Ao baixar o arquivo compactado que contem os fontes, há um diretório chamado doc, que
contém um arquivo de configuração de exemplo, o barman.conf, o qual pode ser usado como modelo.

Como arquivo de configuração do servidor podem ser usados: /etc/barman.conf ou /etc/barman/barman.conf, 
sendo que este último só é considerado na falta do primeiro, caso contrário é ignorado.

Há também como fazer configurações por usuário do servidor de backup, o arquivo ~/.barman.conf.
Esse mesmo as configurações nele contidas sobrescrevem as configurações do servidor pelo usuário.

Para este tutorial usaremos apenas o padrão, o /etc/barman.conf.

==========================================================================

Configuração do Barman

Escopo de Parâmetros


O arquivo de configuração segue o padrão do formato INI e é dividido em:

- [barman] Esta label identifica configurações gerais de backup;

- [nome_do_servidor] Label de servidor. É uma label que serve para configurações
específicas para cada servidor. Seu título não pode ser uma palavra reservada.
Sugere-se o nome do servidor de banco de dados. E como o Barman pode fazer backup 
de vários servidores de banco de dados, podem ter várias labels desse tipo.

all e barman são palavras reservadas e não podem ser usadas como labels de servidores.

O caractere ";" (ponto e vírgula) é usado para fazer comentários

==========================================================================

Configuração do Barman

Diretório de Arquivos de Configuração

O parâmetro de configuração configuration_files_directory nos permite especificar outro diretório de arquivos de configuração.

Similar a outras aplicações Linux, podemos dividir o arquivo de configuração principal em outros arquivos.

Os arquivos devem ter sua nomenclatura terminada em .conf.

É muito útil para separar configurações de um servidor específico ao invés de usar seções no arquivo de configuração principal (barman.conf).

Utilizar um diretório para configurações separadas por servidor é uma boa prática.

Por padrão o diretório é /etc/barman.d 

# mkdir -m 0700 /etc/barman.d 

# touch /etc/barman.d/srv-pgsql.conf

# chown -R barman: /etc/barman*



==========================================================================

Configuração do Barman

Exemplos de arquivos de configuração


Para o laboratório de testes serão usados dois arquivos, sendo que são eles:

- /etc/barman.conf: Arquivo de configuração principal do Barman;

- /etc/barman.d/srv-pgsql.conf: Arquivo de configuração de backup do Barman para o servidor PostgreSQL srv-pgsql.


==========================================================================

Configuração do Barman

Exemplos de arquivos de configuração: /etc/barman.conf

$ vim /etc/barman.conf

; Barman, Gerenciador de Backup and Restauração para PostgreSQL
; http://www.pgbarman.org/ - http://www.2ndQuadrant.com/
;
; Arquivo de configuração princiapl

[barman]
; Diretório principal
barman_home = /var/lib/barman

; Usuário de sistema
barman_user = barman

; Localização de log
log_file = /var/log/barman/barman.log

; Nível de compressão padrão: possíveis valores são None (padrão), bzip2, gzip ou custom
;compression = gzip

; Suporte a Backup Incremental: possíveis valores são None (padrão) link ou copy
;reuse_backup = link

; Scripts de gancho (hook scripts) de backup pre/post
;pre_backup_script = env | grep ^BARMAN
;post_backup_script = env | grep ^BARMAN

; Scripts de gancho de arquivamento (archive hook scripts) pre/post
;pre_archive_script = env | grep ^BARMAN
;post_archive_script = env | grep ^BARMAN

; Diretório de arquivos de configuração. Guarde suas seções em arquivos separados com a extensão .conf
; Por exemplo, guarde a seção 'servidor_01' em /etc/barman.d/servidor_01.conf
configuration_files_directory = /etc/barman.d

; Quantidade mínima de backups requeridos (redundância) - padrão 0
;minimum_redundancy = 0

; Política de retenção global (REDUNDANCY ou RECOVERY WINDOW) - vazio por padrão
;retention_policy =

; Limite global de largura de banda em KBPS - padrão 0 (sem limite)
;bandwidth_limit = 4000

; Checkpoint imediato para comando de backup - padrão false
;immediate_checkpoint = false

; Habilita compressão de rede para transferência de dados - padrão false
;network_compression = false

; Identifica o comportamento padrão para operações de backup: possíveis valores são
; exclusive_backup (padrão), concurrent_backup
;backup_options = exclusive_backup

; Número de tentativas para cópia de dados durante o backup da base após um erro - padrão 0
;basebackup_retry_times = 0

; Número de segundo de espera após uma falha de cópia, antes de tentar de novo - padrão 30
;basebackup_retry_sleep = 30

; Prazo que deve conter a data do último backup.
; Se o último backup for mais velho do que esse prazo, o comando check
; do utilitário barman reportará um erro ao usuário.
; Se o valor for vazio, o último backup é sempre considerado válido.
; A sintaxe deste parâmetro é: "i (DAYS | WEEKS | MONTHS)" onde "i" é um 
; inteiro maior do que zero que identifica o número de dias | semanas | meses de
; validade do último backup deste check. Também conhecido como "smelly backup", 
; que quer dizer "backup malcheiroso".
;last_backup_maximum_age =


==========================================================================

Configuração do Barman

Exemplos de arquivos de configuração: /etc/barman.d/srv-pgsql.conf


$ vim /etc/barman.d/srv-pgsql.conf


;; Configuração do servidor PostgreSQL de nome srv-pgsql
[srv-pgsql]
; Human readable description
description =  "Servidor de testes srv-pgsql"

; Comando SSH
ssh_command = ssh postgres@srv-pgsql

; String de conexão PostgreSQL
conninfo = host=srv-pgsql user=barman password=senha dbname=postgres

; Diretório de arquivamento contínuo do WAL
incoming_wals_directory = /var/lib/barman/bkp/srv-pgsql/incoming

wals_directory = /var/lib/barman/bkp/srv-pgsql/wals



; Quantidade mínima de backups necessários (redundância)
; minimum_redundancy = 1

; Exemplos de política de retenção

; Retention policy (disabled)
; retention_policy =
; Retention policy (based on redundancy)
; retention_policy = REDUNDANCY 2
; Retention policy (based on recovery window)
; retention_policy = RECOVERY WINDOW OF 4 WEEKS


==========================================================================


==========================================================================

Checagens Iniciais


Após criado(s) o(s) arquivo(s) de configuração, agora pode-se testar a configuração do Barman executando os comandos:

- Exibindo informações de um determinado servidor PostgreSQL:

$ barman show-server srv-pgsql

Server srv-pgsql:
	active: True
	archive_command: scp %p barman@srv-backup:/var/lib/barman/bkp/srv-pgsql/incoming/%f
	archive_mode: on
	archived_count: 13
	backup_directory: /var/lib/barman/bkp/srv-pgsql
	backup_options: BackupOptions(['exclusive_backup'])
	bandwidth_limit: None
	basebackup_retry_sleep: 30
	basebackup_retry_times: 0
	basebackups_directory: /var/lib/barman/bkp/srv-pgsql/base
	compression: None
	config_file: /etc/postgresql/9.4/main/postgresql.conf
	conninfo: host=srv-pgsql user=barman password=senha dbname=postgres
	current_archived_wals_per_second: 1.2560551524e-05
	current_xlog: 00000001000000000000000C
	custom_compression_filter: None
	custom_decompression_filter: None
	data_directory: /var/lib/postgresql/9.4/main
	description: Servidor de testes srv-pgsql
	failed_count: 93
	hba_file: /etc/postgresql/9.4/main/pg_hba.conf
	ident_file: /etc/postgresql/9.4/main/pg_ident.conf
	immediate_checkpoint: False
	incoming_wals_directory: /var/lib/barman/bkp/srv-pgsql/incoming
	is_archiving: True
	last_archived_time: 2015-04-22 09:57:01.648311-03:00
	last_archived_wal: 00000001000000000000000C.00000024.backup
	last_backup_maximum_age: None
	last_failed_time: 2015-04-22 08:10:27.530661-03:00
	last_failed_wal: 000000010000000000000008
	lock_file: /var/lib/barman/bkp/srv-pgsql/srv-pgsql.lock
	minimum_redundancy: 0
	network_compression: False
	pgespresso_installed: False
	post_archive_script: None
	post_backup_script: None
	pre_archive_script: None
	pre_backup_script: None
	retention_policy: None
	retention_policy_mode: auto
	reuse_backup: None
	server_txt_version: 9.4.1
	ssh_command: ssh postgres@srv-pgsql
	stats_reset: 2015-04-10 10:30:59.985508-03:00
	tablespace_bandwidth_limit: None
	wal_retention_policy: main
	wals_directory: /var/lib/barman/bkp/srv-pgsql/wals

Uma boa prática é redirecionar essas informações para um arquivo, o qual possa ser consultado futuramente:

$ barman show-server srv-pgsql > /var/lib/barman/bkp/srv-pgsql/server_info.txt

- Fazendo verificações em um servidor PostgreSQL:

$ barman check srv-pgsql

Server srv-pgsql:
	ssh: OK
	PostgreSQL: OK
	archive_mode: OK
	archive_command: OK
	continuous archiving: OK
	directories: OK
	retention policy settings: OK
	backup maximum age: OK (no last_backup_maximum_age provided)
	compression settings: OK
	minimum redundancy requirements: OK (have 1 backups, expected at least 0)


Caso houver alguma falha, além de ser apontado no resultado como mostrado anteriormente, consulte também o log.

O comando barman check cria automaticamente todos os diretórios para o backup contínuo do servidor de banco de dados.

==========================================================================

Listando os Servidores Configurados

O seguinte comando exibe uma lista de todos servidores de banco de dados cadastrados no Barman:

$ barman list-server

srv-pgsql - Servidor de testes srv-pgsql


==========================================================================

Executando um Backup Completo

Para fazer em um servidor específico, como o srv-pgsql, por exemplo, dê o seguinte comando:

$ barman backup srv-pgsql

Starting backup for server srv-pgsql in /var/lib/barman/bkp/srv-pgsql/base/20150422T095654
Backup start at xlog location: 0/C000024 (00000001000000000000000C, 00000024)
Copying files.
Copy done.
Backup size: 32.4 MiB
Asking PostgreSQL server to finalize the backup.
Backup end at xlog location: 0/C0000A8 (00000001000000000000000C, 000000A8)
Backup completed
Processing xlog segments for srv-pgsql
	00000001000000000000000C
	00000001000000000000000C.00000024.backup

É possível também serializar o backup dos servidores gerenciados usando a palavra-chave "all" no lugar do nome de servidor:

$ barman backup all 


Isso vai iterar através da lista de servidores disponíveis e fará um backup para cada um deles.

==========================================================================

Checkpoint Imediato - Parâmetro immediate_checkpoint (padrão: false)


Antes de começar um backup, o PostgreSQL faz um checkpoint, o que gera uma carga de trabalho adicional.
Normalmente o checkpoint tem sua carga atenuada, feita em doses menores ao longo do tempo, o que significa queo o backup pode ser mais lento.
Se o parâmetro de configuração immediate_checkpoint é configurado como true, o PostgreSQL não limitará a carga de trabalho e o checkpoint será feito na velocidade máxima, iniciando o backup assim que possível. O equivalente a dar o comando [1] SELECT pg_start_backup('label', true);
O parâmetro de configuração immediate_checkpoint pode também ser sobrescrito pelos argumentos do utilitário barman:

    --immediate-checkpoint: força um checkpoint imediato;
    --no-immediate-checkpoint: faz com que o checkpoint seja feito respeitando a fração de tempo estipulada no parâmetro do PostgreSQL [2] checkpoint_completion_target. O backup esperará o processo de checkpoint normalmente, respeitando a fração de tempo de checkpoint_completion_target.


[1] http://www.postgresql.org/docs/9.1/static/continuous-archiving.html (24.3.2. Making a Base Backup)
[2] http://www.postgresql.org/docs/9.1/static/runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET



==========================================================================

Exibindo a Lista de Backups de um Servidor


Para listar todos os backups disponíveis de um dado servidor:

$ barman list-backup srv-pgsql

srv-pgsql 20150422T095654 - Wed Apr 22 09:57:00 2015 - Size: 32.4 MiB - WAL Size: 0 B (tablespaces: tbspc_pagila:/var/lib/postgresql/9.4/tblspc/pagila, tbspc_pagila_actor:/var/lib/postgresql/9.4/tblspc/pagila/actor)

srv-pgsql: Nome do servidor PostgreSQL;
20150422T095654: ID do backup;
Wed Apr 22 09:57:00 2015: Data e hora do backup (monento em que iniciou o backup);
Size: 32.4 MiB: Tamanho do backup;
WAL Size: 0 B: Tamanho dos arquivos de WAL arquivados.
(tablespaces: tbspc_pagila:/var/lib/postgresql/9.4/tblspc/pagila, tbspc_pagila_actor:/var/lib/postgresql/9.4/tblspc/pagila/actor): Lista de tablespaces.

A palavra-chave "all" também pode ser utilizada para verificar os backups de todos os servidores cadastrados:

$ barman list-backup all


==========================================================================

Apelidos de Backup IDs

Podem ser usados qualquer um dos seguintes apelidos para identificar um backup em particular para um dado servidor,
de acordo com a ordem cronológica:

- latest/last: o último backup disponível para o servidor.
- oldest/first: o backup mais antigo de um servidor.

Esses apelidos podem ser usados com qualquer um dos seguintes comandos do barman: show­-backup, delete, list­-files ou recover.



As of version 1.1.2, you can use any of the following shortcuts to identify a particular backup for a given server:

    latest: the latest available backup for that server, in chronological order. You can also use the last synonym.
    oldest: the oldest available backup for that server, in chronological order. You can also use the first synonym.

==========================================================================



Restaurando um Servidor


Caso o Barman tenha sido instalado no mesmo servidor de banco de dados pode ser feita uma recuperação local:

$ barman recover srv-pgsql 20150422T095654 /tmp/teste/

20150422T095654 é o ID de backup a ser restaurado.

Quando o comando termina com sucesso, o diretório /tmp/teste conterá um diretório de dados completo pronto para ser iniciado como um servidor  de banco de dados PostgreSQL.

Um exemplo de como esse servidor pode ser inicializado:

$ pg_ctl -D /tmp/teste/ start

Importante:

Se esse comando foi rodado como usuário barman, ele se tornará o super usuário do banco de dados.

Com exceção do diretório pg_tblspc, o Barman não mantém os links simbólicos dentro do PGDATA.
Os administradores de sistema devem ser encorajados para manter o controle de links simbólicos e adicioná-los a procedimentos / planos de recuperação de disastre em caso sejam necessários para serem restaurados em sua localização original.

==========================================================================

Recuperação Remota

O Barman é capaz de recuperar um backup em um servidor remoto através da opção --remote-ssh-command para o comando recover.
Se essa opção é especificada, o barman usa o comando para conectar ao servidor remoto.

Para facilitar nosso trabalho, aproveitando o arquivo criado com as informações do servidor, 
vamos criar uma variável de ambiente com o seguinte comando:

$ export REMOTE_PGDATA=`cat /var/lib/barman/bkp/srv-pgsql/server_info.txt | \
fgrep data_directory | awk '{print $2}'`

A variável de ambiente criada é o PGDATA do servidor a ser restaurado, a qual será
aproveitada no comando de restauração:

$ barman recover --remote-ssh-command='ssh postgres@srv-pgsql' \
srv-pgsql last ${REMOTE_PGDATA}


Obs.:

O usuário postgres é normalment utilizado em um servidor remoto.


Aviso:

Há algumas limitações quando usamos recuperação remota. É importante saber que:

- O Barman precisa de no mínimo 4GB  de espaço livre no diretório temporário (normalmente /tmp):
- A conexão SSH entre o Barman e o servidor remoto deve usar o método de intercâmgio de chaves públicas;
- O usuário remoto deve ser capaz de criar os diretórios de destino para PGDATA e, quando for necessário, tablespaces;
- Deve haver espaço suficiente no servidor remoto para o backup base e os arquivos de WAL necessários para a recuperação.

==========================================================================

Realocação de um ou Mais Tablespaces


Ao fazer uma restauração, com o Barman pode-se redefinir tablespaces através da opção --tablespace.
Logo após a opção --tablespace vem o par nome_do_tablespace:diretorio_de_destino.

$ barman recover --tablespace tbspc_pagila:/tmp/ts/pagila \
--tablespace tbspc_pagila_actor:/tmp/ts/pagila/actor srv-pgsql last /tmp/teste

Se o diretório de destino não existe, o Barman o criará (se tiver privilégios suficientes para isso).

==========================================================================

PITR -  Restauração com a Máquina do Tempo

O PostgreSQL, como outros sistemas gerenciadores de banco de dados oferece um sistema
de recuperação de desastre tomando como base um determinado momento.

É possível restaurar a base de dados para esse dado momento.

Esse momento pode ser especificado como opções:

--target-time TARGET_TIME: para especificar um timestamp;
--target-xid TARGET_XID: para especificar uma transaction ID;
--target-name TARGET_NAME: para especificar um nome de ponto de restauração, que foi previamente criado com a função 
pg_create_restore_point(nome_do_ponto_de_restauracao, disponível a partir da versão 9.1 do PostgreSQL.


Pode ser utilizada a opção --exclusive para especificar se o intervalo de linha de tempo a ser considerado exclui ou não o alvo de recuperação (recovery target). Por padrão é False, o que faz com que o alvo de recuperação seja incluído na linha do tempo a ser considerada.

O Barman permite também específicar uma linha de tempo alvo para recuperalçaim utilizando a opção --target-tli.


Ref.: http://www.postgresql.org/docs/current/static/recovery-target-settings.html

==========================================================================

PITR -  Restauração com a Máquina do Tempo

Laboratório de Exemplo


Para fins de fixação, na prática será dado um exemplo em que haverá perda de dados a ser recuperada.


No servidor de banco de dados, como usuário postgres, fazer o insert de 6 (seis) registros novos:

psql -d pagila -c \
"INSERT INTO actor (first_name,last_name) VALUES
('Roberto','Vivar'),
('Ramón','Bolaños'),
('Florinda','de las Nieves'),
('Carlos','Valdez'),
('María Antonieta','Meza'),
('Edgar','Villagrán');"


Em seguida, no servidor de backup, fazer um backup do servidor srv-pgsql:

$ barman backup srv-pgsql
 
Starting backup for server srv-pgsql in /var/lib/barman/bkp/srv-pgsql/base/20150427T092404
Backup start at xlog location: 0/18000024 (000000010000000000000018, 00000024)
Copying files.
Copy done.
Backup size: 32.4 MiB
Asking PostgreSQL server to finalize the backup.
Backup end at xlog location: 0/180000A8 (000000010000000000000018, 000000A8)
Backup completed
Processing xlog segments for srv-pgsql
	000000010000000000000017
	000000010000000000000018
	000000010000000000000018.00000024.backup


No servidor de banco de dados verificar a data:

$ date
Mon Apr 27 09:25:00 BRT 2015

Ou com um formato mais apropriado para a operação de recover:

$ date "+%Y-%m-%d %H:%M:%S"
2015-04-27 09:25:00

Fazendo uma consulta dos registros inseridos:

$ psql -d pagila -c "SELECT * FROM actor WHERE actor_id > 200;"
 actor_id |   first_name    |   last_name   |        last_update         
----------+-----------------+---------------+----------------------------
      201 | Roberto         | Vivar         | 2015-04-27 09:09:11.434475
      202 | Ramón           | Bolaños       | 2015-04-27 09:09:11.434475
      203 | Florinda        | de las Nieves | 2015-04-27 09:09:11.434475
      204 | Carlos          | Valdez        | 2015-04-27 09:09:11.434475
      205 | María Antonieta | Meza          | 2015-04-27 09:09:11.434475
      206 | Edgar           | Villagrán     | 2015-04-27 09:09:11.434475

Causando o desastre, ou seja, uma remoção de dados "acidental":

$ psql -d pagila -c "DELETE FROM actor WHERE actor_id > 200 RETURNING first_name, last_name;"

   first_name    |   last_name   
-----------------+---------------
 Roberto         | Vivar
 Ramón           | Bolaños
 Florinda        | de las Nieves
 Carlos          | Valdez
 María Antonieta | Meza
 Edgar           | Villagrán
(6 rows)

DELETE 6

Os registros foram apagados.


Fazendo novamente a query para verificar os registros:

$ psql -d pagila -c "SELECT * FROM actor WHERE actor_id > 200;"

 actor_id | first_name | last_name | last_update 
----------+------------+-----------+-------------
(0 rows)

Nada encontrado...

Parando o serviço de banco de dados:

$ pg_ctl stop


No servidor de backup, criar uma variável de ambiente com o diretório de dados do servidor de banco de dados:

$ export REMOTE_PGDATA=`cat /var/lib/barman/bkp/srv-pgsql/server_info.txt | \
fgrep data_directory | awk '{print $2}'`

Utilizar a variável de ambiente para fazer a recuperação remota:

$ barman recover srv-pgsql --remote-ssh-command='ssh postgres@srv-pgsql' \
--target-time='2015-04-27 09:25:00' last ${REMOTE_PGDATA}

Starting remote restore for server srv-pgsql using backup 20150427T092404 
Destination directory: /var/lib/postgresql/9.4/main
	16870, tbspc_pagila, /var/lib/postgresql/9.4/tblspc/pagila
	16871, tbspc_pagila_actor, /var/lib/postgresql/9.4/tblspc/pagila/actor
Doing PITR. Recovery target time: '2015-04-27 09:25:00'
Using safe horizon time for smart rsync copy: 2015-04-22 09:56:54.573393-03:00
Copying the base backup.
Copying required wal segments.
Generating recovery.conf
Disabling dangerous settings in destination directory.
The archive_command was set to 'false' to prevent data losses.

Your PostgreSQL server has been successfully prepared for recovery!

Please review network and archive related settings in the PostgreSQL
configuration file before starting the just recovered instance.

WARNING: Before starting up the recovered PostgreSQL server,
please review also the settings of the following configuration
options as they might interfere with your current recovery attempt:

    data_directory = '/var/lib/postgresql/9.4/main'		# use data in another directory
    external_pid_file = '/var/run/postgresql/9.4-main.pid'			# write an extra PID file
    hba_file = '/etc/postgresql/9.4/main/pg_hba.conf'	# host-based authentication file
    ident_file = '/etc/postgresql/9.4/main/pg_ident.conf'	# ident configuration file

Recovery completed successful.

Aviso: Após fazer a recuperação, caso no diretório de dados (PGDATA) houver links simbólicos que não sejam os contidos em pg_tblspc, os mesmos devem ser restaurados manualmente.
É recomendável que isso esteja documentado!



Após o processo de recuperação remota ser finalizado com sucesso, no servidor PostgreSQL inicializar o serviço do banco de dados:

$ pg_ctl start


Fazer o teste com a consulta:

$ psql -d pagila -c "SELECT * FROM actor WHERE actor_id > 200;"
 actor_id |   first_name    |   last_name   |        last_update         
----------+-----------------+---------------+----------------------------
      207 | Roberto         | Vivar         | 2015-04-27 09:23:31.559312
      208 | Ramón           | Bolaños       | 2015-04-27 09:23:31.559312
      209 | Florinda        | de las Nieves | 2015-04-27 09:23:31.559312
      210 | Carlos          | Valdez        | 2015-04-27 09:23:31.559312
      211 | María Antonieta | Meza          | 2015-04-27 09:23:31.559312
      212 | Edgar           | Villagrán     | 2015-04-27 09:23:31.559312


Registros recuperados com sucesso! :D



==========================================================================

Novas Tentativas de Cópia em Operações de Backup e Recovery

A partir da versão 1.3.3, é possível tirar vantagem de duas novas opções no Barman:

- basebackup_retry_times (padrão: 0)
- basebackup_retry_sleep (padrão: 30)

Quando é usado como opção do Barman backup ou recovery,o Barman tenta fazer a cópia da base uma vez.
Caso houver alguma falha (e.g. problemas de rede) o Barman termina a operação  com uma falha.

Ao configurar basebackup_retry_times, o Barman tentará executar novamente a operação de cópia, tantas vezes o número especificado nessa configuração.

A configuração basebackup_retry_sleep define a quantidade de segundos que o Barman esperará entre outra tentativa.

É possível sobrescrever essas configurações via linha de comando, ao utilizar backup ou recover:

    --retry-times <numero_de_tentativas> (o mesmo que basebackup_retry_times)
    --no-retry (o mesmo que --retry-times 0)
    --retry-sleep <numero_de_segundos> (a mesma lógica que basebackup_retry_sleep)

==========================================================================

Comandos Disponíveis

Os comandos do Barman são aplicados a três níveis diferentes:

Gerais: catálogo de backup;
De Servidores: se aplicam a um servidor específico (lista backups disponíveis, executam backup, etc.);
De Backup: se aplicam a um backup específico no catálogo (informações em tela, fazer uma recuperação, apagar um backup, etc.).

==========================================================================

Comandos Disponíveis

Comandos Gerais

Listar Servidores Disponíveis

Os servidores de banco de dados configurados podem ser exibidos da seguinte maneira:

$ barman list-server
srv-pgsql - Servidor de testes srv-pgsql


==========================================================================
Comandos Disponíveis

Comandos Gerais

Modo de Manutenção

Operações de manutenção no Barman são coisas como compressão de arquivos WAL e movê-los do diretório incoming para o archived.
O modo de manutenção é através da opção cron:

$ barman cron

Esse comando força a política de retenção que estiver configurada nos servidores que tiver:

    retention_policy não vazia e válida;
    retention_policy_mode configurada para auto.

Obs.:

Este comando deve ser executado em um script cron.
Recomenda-se agendar o comando barman para rodar a cada minuto.

==========================================================================

Comandos Disponíveis

Comandos de Servidor

Exibe a configuração de um dado servidor:

barman show-server <server_name>

==========================================================================

Comandos Disponíveis

Comandos de Servidor

Backup Full

Fazer um backup inteiro (full backup), também conhecido como backup base (base backup):

$ barman backup [--immediate-checkpoint] nome_do_servidor

Dica:

É possível utilizar a palavra-chave all para fazer backup de todos os servidores configurados sequencialmente.

==========================================================================

Comandos Disponíveis

Comandos de Servidor

Exibir Backups de um Servidor

Listando o catálogo de backups de um dado servidor:

$ barman list-backup <server_name>

==========================================================================

Comandos Disponíveis

Comandos de Servidor

Checagem de Conexão a Servidor


Verificando a conexão a um determinado servidor:

$ barman check <server_name>

Dica:

A palavra-chave all pode ser utilizada para checar todos servidores configurados.

Ao configurar o parâmetro last_backup_maximum_age, pode-se determinar qual o tempo máximo de backup do último backup feito.
Sendo que se caso esse último backup estiver mais velho do que o valor configurado para esse parâmetro, na checagem de servidor será apresentada uma falha.

A sintaxe dessa configuração é a seguinte:

last_backup_maximum_age = {valor {DAYS | WEEKS | MONTHS}}

Onde valor é um número possitivo representando ou dias, ou semanas ou meses.

==========================================================================

Diagnóstico de uma Instalação do Barman

É possível reunir informações sobre tudo o que está configurado no servidor de backup usando o seguinte comando:

$ barman diagnose

Esse comando tem sua saída no formato JSON, fornecendo informações úteis como configuração global, versões de SSH, Python e rsync, bem como a atual configuração e status de todos servidores.

Dica: 

O diagnóstico pode ser usado quando se deseja responder questões ou reportar erros para desenvolvedores do Barman, fornecendo a eles todas informações sobre um determinado questionamento.

==========================================================================

Reconstruir o Arquivamento do WAL


A qualquer momento pode-se regenar o conteúdo de arquivamento do WAL para um servidor específico, ou utilizando a palavra-chave "all" para todos servidors.




The WAL archive is contained in the xlog.db file, and every Barman server has its own copy. 
From version 1.2.4 you can now rebuild the xlog.db file with the rebuild-xlogdb command. 
This will scan all the archived WAL files and regenerate the metadata for the archive.

Important

Users of Barman < 1.2.3 might have suffered from a bug due to bad locking in highly concurrent environments. You can now regenerate the WAL archive using the rebuild-xlogdb command.

$ barman rebuild-xlogdb <server_name>

==========================================================================

Backup commands

Note

Remember: a backup ID can be retrieved with barman list-backup <server_name>
Show backup information

You can show all the available information for a particular backup of a given server with:

barman show-backup <server_name> <backup_id>

From version 1.1.2, in order to show the latest backup, you can issue:

$ barman show-backup <server_name> latest

==========================================================================

Delete a backup

You can delete a given backup with:

barman delete <server_name> <backup_id>

From version 1.1.2, in order to delete the oldest backup, you can issue:

barman delete <server_name> oldest

Warning

Until retention policies are natively supported, you must use the oldest shortcut with extreme care and caution. Iteratively executing this command can easily wipe out your backup archive.
List backup files

You can list the files (base backup and required WAL files) for a given backup with:

barman list-files [--target TARGET_TYPE] <server_name> <backup_id>

With the --target TARGET_TYPE option, it is possible to choose the content of the list for a given backup.

Possible values for TARGET_TYPE are:

    data: lists just the data files;
    standalone: lists the base backup files, including required WAL files;
    wal: lists all WAL files from the beginning of the base backup to the start of the following one (or until the end of the log);
    full: same as data + wal.

The default value for TARGET_TYPE is standalone.

Important

The list-files command facilitates interaction with external tools, and therefore can be extremely useful to integrate Barman into your archiving procedures.

==========================================================================
Main features
Incremental backup

From version 1.4.0, Barman implements file-level incremental backup. Incremental backup is a kind of full periodic backup which saves only data changes from the latest full backup available in the catalogue for a specific PostgreSQL server. It must not be confused with differential backup, which is implemented by WAL continuous archiving.

The main goals of incremental backup in Barman are:

    Reduce the time taken for the full backup process
    Reduce the disk space occupied by several periodic backups (data deduplication)

This feature heavily relies on rysnc and hard links, which must be therefore supported by both the underlying operating system and the file system where the backup data resides.

The main concept is that two periodic base backups will share those files that have not changed, leading to relevant savings in disk usage. This is particularly true of VLDB contexts and, more in general, of those databases containing a high percentage of read-only historical tables.

Barman implements incremental backup through a global/server option, called reuse_backup, that transparently manages the barman backup command. It accepts three values:

    off: standard full backup (default)
    link: incremental backup, by reusing the last backup for a server and creating a hard link of the unchanged files (for backup space and time reduction)
    copy: incremental backup, by reusing the last backup for a server and creating a copy of the unchanged files (just for backup time reduction)

The most common scenario is to set reuse_backup to link, as follows:

reuse_backup = link

Setting this at global level will automatically enable incremental backup for all your servers.

As a final note, users can override the setting of the reuse_backup option through the --reuse-backup runtime option for the barman backup command. Similarly, the runtime option accepts three values: off, link and copy. For example, you can run a one-off incremental backup as follows:

barman backup --reuse-backup=link <server_name>

==========================================================================

WAL compression

The barman cron command (see below) will compress WAL files if the compression option is set in the configuration file. This option allows three values:

    gzip: for Gzip compression (requires gzip)
    bzip2: for Bzip2 compression (requires bzip2)
    custom: for custom compression, which requires you to set the following options as well:
        custom_compression_filter: a compression filter
        custom_decompression_filter: a decompression filter

==========================================================================

Limiting bandwidth usage

From version 1.2.1, it is possible to limit the usage of I/O bandwidth through the bandwidth_limit option (global/per server), by specifying the maximum number of kilobytes per second. By default it is set to 0, meaning no limit.

In case you have several tablespaces and you prefer to limit the I/O workload of your backup procedures on one or more tablespaces, you can use the tablespace_bandwidth_limit option (global/per server):

tablespace_bandwidth_limit = tbname:bwlimit[, tbname:bwlimit, ...]

The option accepts a comma separated list of pairs made up of the tablespace name and the bandwidth limit (in kilobytes per second).

When backing up a server, Barman will try and locate any existing tablespace in the above option. If found, the specified bandwidth limit will be enforced. If not, the default bandwidth limit for that server will be applied.
Network Compression

From version 1.3.0 it is possible to reduce the size of transferred data using compression. It can be enabled using the network_compression option (global/per server):

network_compression = true|false

Setting this option to true will enable data compression during network transfers (for both backup and recovery). By default it is set to false.
Backup ID shortcuts

Minimum redundancy safety


From version 1.2.0, you can define the minimum number of periodic backups for a PostgreSQL server.

You can use the global/per server configuration option called minimum_redundancy for this purpose, by default set to 0.

By setting this value to any number greater than 0, Barman makes sure that at any time you will have at least that number of backups in a server catalogue.

This will protect you from accidental barman delete operations.

Important

Make sure that your policy retention settings do not collide with minimum redundancy requirements. Regularly check Barman’s log for messages on this topic.

==========================================================================
Retention policies

From version 1.2.0, Barman supports retention policies for backups.

A backup retention policy is an user-defined policy that determines how long backups and related archive logs (Write Ahead Log segments) need to be retained for recovery procedures.

Based on the user’s request, Barman retains the periodic backups required to satisfy the current retention policy, and any archived WAL files required for the complete recovery of those backups.

Barman users can define a retention policy in terms of backup redundancy (how many periodic backups) or a recovery window (how long).

Retention policy based on redundancy
    In a redundancy based retention policy, the user determines how many periodic backups to keep. A redundancy-based retention policy is contrasted with retention policies that use a recovery window. 
Retention policy based on recovery window
    A recovery window is one type of Barman backup retention policy, in which the DBA specifies a period of time and Barman ensures retention of backups and/or archived WAL files required for point-in-time recovery to any time during the recovery window. The interval always ends with the current time and extends back in time for the number of days specified by the user. For example, if the retention policy is set for a recovery window of seven days, and the current time is 9:30 AM on Friday, Barman retains the backups required to allow point-in-time recovery back to 9:30 AM on the previous Friday. 

Scope

Retention policies can be defined for:

    PostgreSQL periodic base backups: through the retention_policy configuration option;
    Archive logs, for Point-In-Time-Recovery: through the wal_retention_policy configuration option.

Important

In a temporal dimension, archive logs must be included in the time window of periodic backups.

There are two typical use cases here: full or partial point-in-time recovery.

Full point in time recovery scenario
    Base backups and archive logs share the same retention policy, allowing DBAs to recover at any point in time from the first available backup. 
Partial point in time recovery scenario
    Base backup retention policy is wider than that of archive logs, allowing users for example to keep full weekly backups of the last 6 months, but archive logs for the last 4 weeks (granting to recover at any point in time starting from the last 4 periodic weekly backups). 

Important

Currently, Barman implements only the full point in time recovery scenario, by constraining the wal_retention_policy option to main.
How they work

Retention policies in Barman can be:

    automated: enforced by barman cron;
    manual: Barman simply reports obsolete backups and allows DBAs to delete them.

Important

Currently Barman does not implement manual enforcement. This feature will be available in future versions.
Configuration and syntax

Retention policies can be defined through the following configuration options:

    retention_policy: for base backup retention;
    wal_retention_policy: for archive logs retention;
    retention_policy_mode: can only be set to auto (retention policies are automatically enforced by the barman cron command).

These configuration options can be defined both at a global level and a server level, allowing users maximum flexibility on a multi-server environment.
Syntax for retention_policy

The general syntax for a base backup retention policy through retention_policy is the following:

retention_policy = {REDUNDANCY value | RECOVERY WINDOW OF value {DAYS | WEEKS | MONTHS}}

Where:

    syntax is case insensitive;
    value is an integer and is > 0;
    in case of redundancy retention policy:
        value must be greater than or equal to the server minimum redundancy level (if not is is assigned to that value and a warning is generated);
        the first valid backup is the value-th backup in a reverse ordered time series;
    in case of recovery window policy:
        the point of recoverability is: current time - window;
        the first valid backup is the first available backup before the point of recoverability; its value in a reverse ordered time series must be greater than or equal to the server minimum redundancy level (if not is is assigned to that value and a warning is generated).

By default, retention_policy is empty (no retention enforced).
Syntax for wal_retention_policy

Currently, the only allowed value for wal_retention_policy is the special value main, that maps the retention policy of archive logs to that of base backups.
Concurrent Backup and backup from a standby

Normally, during backup operations, Barman uses PostgreSQL native functions pg_start_backup and pg_stop_backup for exclusive backup. These operations are not allowed on a read-only standby server.

As of version 1.3.1, Barman is also capable of performing backups of PostgreSQL 9.2/9.3 database servers in a concurrent way, primarily through the backup_options configuration parameter.
[Concurrent backup is a technology that has been available in PostgreSQL since version 9.1, through the streaming replication protocol (using, for example, a tool like pg_basebackup).]
This introduces a new architecture scenario with Barman: backup from a standby server, using rsync.

Important

Concurrent backup requires users of PostgreSQL 9.2 and 9.3 to install the pgespresso open source extension on the PostgreSQL server. Detailed information as well as the source code of pgespresso can be found at https://github.com/2ndquadrant-it/pgespresso.

By default, backup_options is transparently set to exclusive_backup (the only supported method by any Barman version prior to 1.3.1).

When backup_options is set to concurrent_backup, Barman activates the concurrent backup mode for a server and follows these two simple rules:

    ssh_command must point to the destination Postgres server;
    conninfo must point to a database on the destination Postgres 9.2 or 9.3 server where pgespresso is correctly installed through CREATE EXTENSION.

The destination Postgres server can be either the master or a streaming replicated standby server.

Note

When backing up from a standby server, continuous archiving of WAL files must be configured on the master to ship files to the Barman server (as outlined in the "Continuous WAL archiving" section above).
[ In case of concurrent backup, currently Barman does not have a way to determine that the closing WAL file of a full backup has actually been shipped - opposite to the case of an exclusive backup where it is Postgres itself that makes sure that the WAL file is correctly archived. Be aware that the full backup cannot be considered consistent until that WAL file has been received and archived by Barman. We encourage Barman users to wait to delete the previous backup - at least until that moment. ]
Hook scripts

Barman allows a database administrator to run hook scripts on these two events:

    before and after a backup
    before and after a WAL file is archived

Important

No check is performed on the exit code of a script. The result will be simply written in the log file.
Backup scripts

Version 1.1.0 introduced backup scripts.

These scripts can be configured with the following global configuration options (which can be overridden on a per server basis):

    pre_backup_script: hook script launched before a base backup
    post_backup_script: hook script launched after a base backup

The script definition is passed to a shell and can return any exit code.

The shell environment will contain the following variables:

    BARMAN_BACKUP_DIR: backup destination directory
    BARMAN_BACKUP_ID: ID of the backup
    BARMAN_CONFIGURATION: configuration file used by barman
    BARMAN_ERROR: error message, if any (only for the post phase)
    BARMAN_PHASE: phase of the script, either pre or post
    BARMAN_PREVIOUS_ID: ID of the previous backup (if present)
    BARMAN_SERVER: name of the server
    BARMAN_STATUS: status of the backup
    BARMAN_VERSION: version of Barman (from 1.2.1)

WAL archive scripts

Version 1.3.0 introduced WAL archive hook scripts.

Similarly to backup scripts, archive scripts can be configured with global configuration options (which can be overridden on a per server basis):

    pre_archive_script: hook script launched before a WAL file is archived by maintenance (usually barman cron)
    post_archive_script: hook script launched after a WAL file is archived by maintenance

The script is executed through a shell and can return any exit code.

Archive scripts share with backup scripts some environmental variables:

    BARMAN_CONFIGURATION: Arquivo de configuração usado pelo Barman
    BARMAN_ERROR: mensagem de erro, se qualquer (apenas para a fase post)
    BARMAN_PHASE: Fase doscript, ou pre ou post
    BARMAN_SERVER: Nome do servidor

Following variables are specific to archive scripts:

    BARMAN_SEGMENT: Nome do arquivo de segmento do WAL
    BARMAN_FILE: CAminho completo do arquivo do WAL
    BARMAN_SIZE: Tamanho do arquivo do WAL
    BARMAN_TIMESTAMP: Timestamp do arquivo do WAL
    BARMAN_COMPRESSION: Tipo de de compressão usada no arquivo de WAL

Support and sponsor opportunities

Barman is free software, written and maintained by 2ndQuadrant. If you require support on using Barman, or if you need new features, please get in touch with 2ndQuadrant. You can sponsor the development of new features of Barman and PostgreSQL which will be made publicly available as open source.

For further information, please visit our websites:

    Barman website: http://www.pgbarman.org/
    Support section on the website: http://www.pgbarman.org/support/
    2ndQuadrant website: http://www.2ndquadrant.com/

Useful information can be found in:

    the FAQ section of the website: http://www.pgbarman.org/faq/
    the "Barman" category of 2ndQuadrant’s blog: http://blog.2ndquadrant.com/tag/barman/

Important

When submitting requests on the mailing list, please always report the output of the barman diagnose command.

==========================================================================

==========================================================================














